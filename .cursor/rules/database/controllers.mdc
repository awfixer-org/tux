---
description: Database controller patterns, BaseController usage, CRUD operations, and query patterns for Tux
globs: src/tux/database/controllers/**/*.py
---

# Database Controllers

## Overview

Tux uses a controller pattern for database operations. All controllers inherit from `BaseController` which provides CRUD, query, pagination, bulk operations, and transaction management.

## Controller Structure

### Base Controller Pattern

```python
from tux.database.controllers.base import BaseController
from tux.database.models import MyModel
from tux.database.service import DatabaseService

class MyModelController(BaseController[MyModel]):
    """Controller for MyModel operations."""

    def __init__(self, db: DatabaseService) -> None:
        super().__init__(MyModel, db)
```

✅ **GOOD:** Inherits from BaseController, proper typing, DatabaseService injection

❌ **BAD:** Direct database access, missing BaseController

```python
# ❌ BAD: Direct session access
class MyModelController:
    async def get(self, session: AsyncSession, id: int):
        return await session.get(MyModel, id)
```

## CRUD Operations

### Create

```python
# ✅ GOOD: Use controller's create method
controller = MyModelController(db)
new_model = await controller.create(
    name="Example",
    description="Description"
)

# Returns created model instance
```

❌ **BAD:** Direct session operations

```python
# ❌ BAD: Don't access session directly
async with db.session() as session:
    model = MyModel(name="Example")
    session.add(model)
    await session.commit()
```

### Read

```python
# Get by ID
model = await controller.get(id=123)

# Get by filters
models = await controller.get_many(name="Example")

# Get first matching
model = await controller.get_first(name="Example")
```

✅ **GOOD:** Use controller methods, proper filtering

### Update

```python
# ✅ GOOD: Use update method
updated = await controller.update(
    id=123,
    name="New Name",
    description="New Description"
)

# Partial update
updated = await controller.update(
    id=123,
    name="New Name"
    # Only updates name, leaves other fields unchanged
)
```

❌ **BAD:** Manual update logic

```python
# ❌ BAD: Manual update
async with db.session() as session:
    model = await session.get(MyModel, 123)
    model.name = "New Name"
    await session.commit()
```

### Delete

```python
# ✅ GOOD: Use delete method
deleted = await controller.delete(id=123)

# Soft delete (if model supports it)
deleted = await controller.soft_delete(id=123)
```

## Query Operations

### Filtering

```python
# ✅ GOOD: Use query controller methods
models = await controller.query.filter(
    name="Example",
    status="active"
).all()

# Complex filters
models = await controller.query.filter(
    created_at__gte=datetime.now() - timedelta(days=7)
).all()
```

### Ordering

```python
# ✅ GOOD: Use order_by
models = await controller.query.order_by(
    "-created_at"  # Descending
).all()

models = await controller.query.order_by(
    "name",  # Ascending
    "-created_at"  # Then descending
).all()
```

### Pagination

```python
# ✅ GOOD: Use pagination controller
result = await controller.pagination.paginate(
    page=1,
    per_page=20,
    filters={"status": "active"}
)

# result.items - List of models
# result.total - Total count
# result.pages - Total pages
```

## Bulk Operations

```python
# ✅ GOOD: Use bulk controller
await controller.bulk.create_many([
    MyModel(name="Item 1"),
    MyModel(name="Item 2"),
    MyModel(name="Item 3"),
])

await controller.bulk.update_many(
    filters={"status": "old"},
    updates={"status": "new"}
)

await controller.bulk.delete_many(filters={"status": "inactive"})
```

## Transactions

```python
# ✅ GOOD: Use transaction controller
async with controller.transaction.begin():
    model1 = await controller.create(name="Model 1")
    model2 = await controller.create(name="Model 2")
    # Both committed together, or both rolled back on error
```

❌ **BAD:** Manual transaction management

```python
# ❌ BAD: Manual transactions
async with db.session() as session:
    async with session.begin():
        # Manual transaction logic
        pass
```

## Controller Composition

BaseController composes specialized controllers:

- **CrudController** - Basic CRUD operations
- **QueryController** - Query and filtering
- **PaginationController** - Pagination support
- **BulkOperationsController** - Bulk operations
- **TransactionController** - Transaction management
- **PerformanceController** - Performance optimizations
- **UpsertController** - Upsert operations

Access via properties:

```python
# ✅ GOOD: Access specialized controllers
await controller.crud.create(...)
await controller.query.filter(...)
await controller.pagination.paginate(...)
```

## Best Practices

1. **Always use BaseController** - Don't access database directly
2. **Inject DatabaseService** - Use dependency injection
3. **Use controller methods** - Don't bypass controller layer
4. **Handle errors properly** - Let controller handle database errors
5. **Use transactions** - For multi-step operations
6. **Use bulk operations** - For multiple records
7. **Type hints** - Always type controller methods

## Anti-Patterns

1. ❌ **Direct session access** - Always use controllers
2. ❌ **Bypassing controller layer** - Don't access database directly
3. ❌ **Manual transaction management** - Use transaction controller
4. ❌ **Missing error handling** - Let controller handle errors
5. ❌ **No type hints** - Always type controller methods

## See Also

- @database/models.mdc - Model patterns
- @database/services.mdc - Service layer patterns
- @database/queries.mdc - Query optimization patterns
- @AGENTS.md - General coding standards
- @rules.mdc - Complete catalog of all rules and commands
